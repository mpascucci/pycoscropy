<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IOCBIO Deconvolve: deconvolve::Image&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IOCBIO Deconvolve
   </div>
   <div id="projectbrief">Library for deconvolving 3D images</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedeconvolve.html">deconvolve</a></li><li class="navelem"><a class="el" href="classdeconvolve_1_1Image.html">Image</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classdeconvolve_1_1Image-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">deconvolve::Image&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classdeconvolve_1_1Image.html" title="Image class defining memory allocation and all mathematical operations required for deconvolution.">Image</a> class defining memory allocation and all mathematical operations required for deconvolution.  
 <a href="classdeconvolve_1_1Image.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="image_8hpp_source.html">image.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1aff1ad6a3e670315943f4a8631a7eda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a1aff1ad6a3e670315943f4a8631a7eda">Image</a> (std::shared_ptr&lt; <a class="el" href="classdeconvolve_1_1ImageSettings.html">ImageSettings</a>&lt; T &gt; &gt; settings, const std::vector&lt; T &gt; &amp;data, size_t n1, size_t n2, size_t n3, T v1, T v2, T v3)</td></tr>
<tr class="memdesc:a1aff1ad6a3e670315943f4a8631a7eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that copies user-provided data.  <a href="classdeconvolve_1_1Image.html#a1aff1ad6a3e670315943f4a8631a7eda">More...</a><br /></td></tr>
<tr class="separator:a1aff1ad6a3e670315943f4a8631a7eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f5d42c9e808abdfb2420bc8bb3759b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#ae0f5d42c9e808abdfb2420bc8bb3759b">Image</a> (std::shared_ptr&lt; <a class="el" href="classdeconvolve_1_1ImageSettings.html">ImageSettings</a>&lt; T &gt; &gt; settings, size_t n1, size_t n2, size_t n3, T v1, T v2, T v3)</td></tr>
<tr class="memdesc:ae0f5d42c9e808abdfb2420bc8bb3759b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that only allocates memory.  <a href="classdeconvolve_1_1Image.html#ae0f5d42c9e808abdfb2420bc8bb3759b">More...</a><br /></td></tr>
<tr class="separator:ae0f5d42c9e808abdfb2420bc8bb3759b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0294f63700543e11c0f0da85601c7ae5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a0294f63700543e11c0f0da85601c7ae5">~Image</a> ()</td></tr>
<tr class="separator:a0294f63700543e11c0f0da85601c7ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48349ede7bab0a7f4dc788bea34b2f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#ad48349ede7bab0a7f4dc788bea34b2f5">Image</a> ()=delete</td></tr>
<tr class="separator:ad48349ede7bab0a7f4dc788bea34b2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af623c8e66010db8e6668d957658a12c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#af623c8e66010db8e6668d957658a12c0">Image</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;)=delete</td></tr>
<tr class="separator:af623c8e66010db8e6668d957658a12c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d847695e136547b2b0a45db8003277b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a0d847695e136547b2b0a45db8003277b">operator=</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;)=delete</td></tr>
<tr class="separator:a0d847695e136547b2b0a45db8003277b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae250e2358620e764b32cde5af65c9c1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#ae250e2358620e764b32cde5af65c9c1c">operator bool</a> () const</td></tr>
<tr class="memdesc:ae250e2358620e764b32cde5af65c9c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if image has allocated memory for data.  <a href="classdeconvolve_1_1Image.html#ae250e2358620e764b32cde5af65c9c1c">More...</a><br /></td></tr>
<tr class="separator:ae250e2358620e764b32cde5af65c9c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914965c6f3e5da2da2b505fb58e2c9bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a914965c6f3e5da2da2b505fb58e2c9bd">set</a> (const std::vector&lt; T &gt; &amp;data, size_t n1, size_t n2, size_t n3, T v1, T v2, T v3)</td></tr>
<tr class="memdesc:a914965c6f3e5da2da2b505fb58e2c9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set image data.  <a href="classdeconvolve_1_1Image.html#a914965c6f3e5da2da2b505fb58e2c9bd">More...</a><br /></td></tr>
<tr class="separator:a914965c6f3e5da2da2b505fb58e2c9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c6444954e813629c3b6e62caf03603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a99c6444954e813629c3b6e62caf03603">copy_data</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;im)</td></tr>
<tr class="memdesc:a99c6444954e813629c3b6e62caf03603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from image.  <a href="classdeconvolve_1_1Image.html#a99c6444954e813629c3b6e62caf03603">More...</a><br /></td></tr>
<tr class="separator:a99c6444954e813629c3b6e62caf03603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490de29909c45c482beb8b0b385004ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a490de29909c45c482beb8b0b385004ec">get_image</a> (std::vector&lt; T &gt; &amp;data)</td></tr>
<tr class="memdesc:a490de29909c45c482beb8b0b385004ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get image as a continuous data vector.  <a href="classdeconvolve_1_1Image.html#a490de29909c45c482beb8b0b385004ec">More...</a><br /></td></tr>
<tr class="separator:a490de29909c45c482beb8b0b385004ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7fa78613fcc893581b618a3e2db17b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#acc7fa78613fcc893581b618a3e2db17b">swap</a> (<a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;image)</td></tr>
<tr class="memdesc:acc7fa78613fcc893581b618a3e2db17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps images between this and provided image.  <a href="classdeconvolve_1_1Image.html#acc7fa78613fcc893581b618a3e2db17b">More...</a><br /></td></tr>
<tr class="separator:acc7fa78613fcc893581b618a3e2db17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37407e51adfbaedd79672e9874c50ca0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a37407e51adfbaedd79672e9874c50ca0">same_dims</a> (size_t n1, size_t n2, size_t n3) const</td></tr>
<tr class="memdesc:a37407e51adfbaedd79672e9874c50ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare given dimensions with the dimensions of <code>this</code> image.  <a href="classdeconvolve_1_1Image.html#a37407e51adfbaedd79672e9874c50ca0">More...</a><br /></td></tr>
<tr class="separator:a37407e51adfbaedd79672e9874c50ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ced8c24dbb717d7a2d5335e8540e38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a05ced8c24dbb717d7a2d5335e8540e38">same_dims</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;other) const</td></tr>
<tr class="memdesc:a05ced8c24dbb717d7a2d5335e8540e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare dimensions of the other image with the dimensions of <code>this</code> image.  <a href="classdeconvolve_1_1Image.html#a05ced8c24dbb717d7a2d5335e8540e38">More...</a><br /></td></tr>
<tr class="separator:a05ced8c24dbb717d7a2d5335e8540e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3aaac5f51cf1e0eed7c8fb6e044917"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#aad3aaac5f51cf1e0eed7c8fb6e044917">same_voxel</a> (T v1, T v2, T v3) const</td></tr>
<tr class="memdesc:aad3aaac5f51cf1e0eed7c8fb6e044917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare given voxel sizes with the sizes of <code>this</code> image.  <a href="classdeconvolve_1_1Image.html#aad3aaac5f51cf1e0eed7c8fb6e044917">More...</a><br /></td></tr>
<tr class="separator:aad3aaac5f51cf1e0eed7c8fb6e044917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a126b037912f847da38fffefd5206f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a19a126b037912f847da38fffefd5206f">same_voxel</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;other) const</td></tr>
<tr class="memdesc:a19a126b037912f847da38fffefd5206f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare voxel sizes of the other image with the sizes of <code>this</code> image.  <a href="classdeconvolve_1_1Image.html#a19a126b037912f847da38fffefd5206f">More...</a><br /></td></tr>
<tr class="separator:a19a126b037912f847da38fffefd5206f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595c792b085161110efe5170c6a4cbc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a595c792b085161110efe5170c6a4cbc1">same_settings</a> (const std::shared_ptr&lt; <a class="el" href="classdeconvolve_1_1ImageSettings.html">ImageSettings</a>&lt; T &gt; &gt; settings)</td></tr>
<tr class="memdesc:a595c792b085161110efe5170c6a4cbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if the image settings are the same as the settings given by an argument.  <a href="classdeconvolve_1_1Image.html#a595c792b085161110efe5170c6a4cbc1">More...</a><br /></td></tr>
<tr class="separator:a595c792b085161110efe5170c6a4cbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f9edebff0db3e2b02e526b4e9d4700"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#aa7f9edebff0db3e2b02e526b4e9d4700">compatible</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;other) const</td></tr>
<tr class="memdesc:aa7f9edebff0db3e2b02e526b4e9d4700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if other image is compatible to <code>this</code> image.  <a href="classdeconvolve_1_1Image.html#aa7f9edebff0db3e2b02e526b4e9d4700">More...</a><br /></td></tr>
<tr class="separator:aa7f9edebff0db3e2b02e526b4e9d4700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4cdd5e7aa1d1191faaf1bbf13af025"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a4d4cdd5e7aa1d1191faaf1bbf13af025">fft</a> ()</td></tr>
<tr class="memdesc:a4d4cdd5e7aa1d1191faaf1bbf13af025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies FFT to this image and keeps it in place.  <a href="classdeconvolve_1_1Image.html#a4d4cdd5e7aa1d1191faaf1bbf13af025">More...</a><br /></td></tr>
<tr class="separator:a4d4cdd5e7aa1d1191faaf1bbf13af025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ebe006bdb155c43059abd97b9c0e7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a29ebe006bdb155c43059abd97b9c0e7d">ifft</a> ()</td></tr>
<tr class="memdesc:a29ebe006bdb155c43059abd97b9c0e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies IFFT to this image.  <a href="classdeconvolve_1_1Image.html#a29ebe006bdb155c43059abd97b9c0e7d">More...</a><br /></td></tr>
<tr class="separator:a29ebe006bdb155c43059abd97b9c0e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9f34e977c92dcefe1c7cea729ad834"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#aea9f34e977c92dcefe1c7cea729ad834">convolve</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;kernel)</td></tr>
<tr class="memdesc:aea9f34e977c92dcefe1c7cea729ad834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve this image by the given kernel.  <a href="classdeconvolve_1_1Image.html#aea9f34e977c92dcefe1c7cea729ad834">More...</a><br /></td></tr>
<tr class="separator:aea9f34e977c92dcefe1c7cea729ad834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c1b67b952099a7a1897484bcaaae81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a88c1b67b952099a7a1897484bcaaae81">convolve_conj</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;kernel)</td></tr>
<tr class="memdesc:a88c1b67b952099a7a1897484bcaaae81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve this image by conjugate of the given kernel.  <a href="classdeconvolve_1_1Image.html#a88c1b67b952099a7a1897484bcaaae81">More...</a><br /></td></tr>
<tr class="separator:a88c1b67b952099a7a1897484bcaaae81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab70a4715c14f227f562c6c3f0794e4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#aab70a4715c14f227f562c6c3f0794e4b">invdivide_image</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;image)</td></tr>
<tr class="memdesc:aab70a4715c14f227f562c6c3f0794e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation used in deconvolution: this=image/this.  <a href="classdeconvolve_1_1Image.html#aab70a4715c14f227f562c6c3f0794e4b">More...</a><br /></td></tr>
<tr class="separator:aab70a4715c14f227f562c6c3f0794e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8609ba2231ee72e3b82ba78fe16f1d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#ab8609ba2231ee72e3b82ba78fe16f1d1">prod_image</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;image)</td></tr>
<tr class="memdesc:ab8609ba2231ee72e3b82ba78fe16f1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation used in deconvolution: this=image*this.  <a href="classdeconvolve_1_1Image.html#ab8609ba2231ee72e3b82ba78fe16f1d1">More...</a><br /></td></tr>
<tr class="separator:ab8609ba2231ee72e3b82ba78fe16f1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a144ccbccc3a55763a39083a940aaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a38a144ccbccc3a55763a39083a940aaa">div_unit_grad</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;image)</td></tr>
<tr class="memdesc:a38a144ccbccc3a55763a39083a940aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation used in deconvolution: this=div(grad(image)/mod(grad(image)))  <a href="classdeconvolve_1_1Image.html#a38a144ccbccc3a55763a39083a940aaa">More...</a><br /></td></tr>
<tr class="separator:a38a144ccbccc3a55763a39083a940aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08575c72311855d9c1e163c60615510c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a08575c72311855d9c1e163c60615510c">prod_regularized</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;image, T lambda, const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;div)</td></tr>
<tr class="memdesc:a08575c72311855d9c1e163c60615510c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation used in deconvolution: this=this*(image/(1-lambda*div))  <a href="classdeconvolve_1_1Image.html#a08575c72311855d9c1e163c60615510c">More...</a><br /></td></tr>
<tr class="separator:a08575c72311855d9c1e163c60615510c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9d5ed38d1af60bfef4938d04958af5"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#aeb9d5ed38d1af60bfef4938d04958af5">snr</a> (size_t convolution_kernel_size) const</td></tr>
<tr class="memdesc:aeb9d5ed38d1af60bfef4938d04958af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peak signal-to-noise of this image.  <a href="classdeconvolve_1_1Image.html#aeb9d5ed38d1af60bfef4938d04958af5">More...</a><br /></td></tr>
<tr class="separator:aeb9d5ed38d1af60bfef4938d04958af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a32a20a736cb011bfdd79dac193411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a78a32a20a736cb011bfdd79dac193411">get_stats</a> (T &amp;cmin, T &amp;cmax, T &amp;csum) const</td></tr>
<tr class="memdesc:a78a32a20a736cb011bfdd79dac193411"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdeconvolve_1_1Image.html" title="Image class defining memory allocation and all mathematical operations required for deconvolution.">Image</a> characteristics in terms of extreme values and sum.  <a href="classdeconvolve_1_1Image.html#a78a32a20a736cb011bfdd79dac193411">More...</a><br /></td></tr>
<tr class="separator:a78a32a20a736cb011bfdd79dac193411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74b46e4bbbb05c547d6e7c9dbc74948"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#ab74b46e4bbbb05c547d6e7c9dbc74948">nrm2</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;image) const</td></tr>
<tr class="memdesc:ab74b46e4bbbb05c547d6e7c9dbc74948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean norm between <code>this</code> and provided image.  <a href="classdeconvolve_1_1Image.html#ab74b46e4bbbb05c547d6e7c9dbc74948">More...</a><br /></td></tr>
<tr class="separator:ab74b46e4bbbb05c547d6e7c9dbc74948"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1c715981251d16831d293164ed78958d"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a1c715981251d16831d293164ed78958d">lambda_lsq</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;cconv, const <a class="el" href="classdeconvolve_1_1Image.html">Image</a> &amp;div)</td></tr>
<tr class="memdesc:a1c715981251d16831d293164ed78958d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lambda LSQ calculation.  <a href="classdeconvolve_1_1Image.html#a1c715981251d16831d293164ed78958d">More...</a><br /></td></tr>
<tr class="separator:a1c715981251d16831d293164ed78958d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aef232b3abecf1483bc541a3bd0175bc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#aef232b3abecf1483bc541a3bd0175bc1">allocate_data</a> ()</td></tr>
<tr class="memdesc:aef232b3abecf1483bc541a3bd0175bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate data in the format suitable for the backend.  <a href="classdeconvolve_1_1Image.html#aef232b3abecf1483bc541a3bd0175bc1">More...</a><br /></td></tr>
<tr class="separator:aef232b3abecf1483bc541a3bd0175bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa0200796f28aab5dfe43d9a539b0df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a9fa0200796f28aab5dfe43d9a539b0df">release_data</a> ()</td></tr>
<tr class="memdesc:a9fa0200796f28aab5dfe43d9a539b0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the allocated data.  <a href="classdeconvolve_1_1Image.html#a9fa0200796f28aab5dfe43d9a539b0df">More...</a><br /></td></tr>
<tr class="separator:a9fa0200796f28aab5dfe43d9a539b0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4aa2cc5173baa94983bd9f4dd65e9ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#ac4aa2cc5173baa94983bd9f4dd65e9ae">convolve_implementation</a> (const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;kernel, void(*p)(std::complex&lt; T &gt; *im, std::complex&lt; T &gt; *ker, T scale, size_t sz))</td></tr>
<tr class="memdesc:ac4aa2cc5173baa94983bd9f4dd65e9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of convolution.  <a href="classdeconvolve_1_1Image.html#ac4aa2cc5173baa94983bd9f4dd65e9ae">More...</a><br /></td></tr>
<tr class="separator:ac4aa2cc5173baa94983bd9f4dd65e9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1723bfcefda9544ffc27bad9b408dab2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a1723bfcefda9544ffc27bad9b408dab2">last_dim</a> () const</td></tr>
<tr class="memdesc:a1723bfcefda9544ffc27bad9b408dab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the last dimension in the format used by FFTW.  <a href="classdeconvolve_1_1Image.html#a1723bfcefda9544ffc27bad9b408dab2">More...</a><br /></td></tr>
<tr class="separator:a1723bfcefda9544ffc27bad9b408dab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16382f0ec9774c0ce34b2a19e6bf0d01"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a16382f0ec9774c0ce34b2a19e6bf0d01">data_size</a> () const</td></tr>
<tr class="memdesc:a16382f0ec9774c0ce34b2a19e6bf0d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns data size assuming that its all stored as real numbers.  <a href="classdeconvolve_1_1Image.html#a16382f0ec9774c0ce34b2a19e6bf0d01">More...</a><br /></td></tr>
<tr class="separator:a16382f0ec9774c0ce34b2a19e6bf0d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1afd770e6fea1bbb41b5df86119512f"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#af1afd770e6fea1bbb41b5df86119512f">operator()</a> (size_t i, size_t j, size_t k)</td></tr>
<tr class="memdesc:af1afd770e6fea1bbb41b5df86119512f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the voxel value assuming that <code>this</code> holds real data.  <a href="classdeconvolve_1_1Image.html#af1afd770e6fea1bbb41b5df86119512f">More...</a><br /></td></tr>
<tr class="separator:af1afd770e6fea1bbb41b5df86119512f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f89e72ed76a5a052ee6bb82b03a6ebb"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a2f89e72ed76a5a052ee6bb82b03a6ebb">operator()</a> (size_t i, size_t j, size_t k) const</td></tr>
<tr class="memdesc:a2f89e72ed76a5a052ee6bb82b03a6ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the voxel value assuming that <code>this</code> holds real data.  <a href="classdeconvolve_1_1Image.html#a2f89e72ed76a5a052ee6bb82b03a6ebb">More...</a><br /></td></tr>
<tr class="separator:a2f89e72ed76a5a052ee6bb82b03a6ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3281fa4ff2a8875e7828f3d0ed9223a9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdeconvolve_1_1ImageSettings.html">ImageSettings</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a3281fa4ff2a8875e7828f3d0ed9223a9">m_settings</a></td></tr>
<tr class="memdesc:a3281fa4ff2a8875e7828f3d0ed9223a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings used to allocate memory and keeping configuration of relevant parameters.  <a href="classdeconvolve_1_1Image.html#a3281fa4ff2a8875e7828f3d0ed9223a9">More...</a><br /></td></tr>
<tr class="separator:a3281fa4ff2a8875e7828f3d0ed9223a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ae596c1572e8310fff76a4742f9ff5"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#ad0ae596c1572e8310fff76a4742f9ff5">m_data</a> = nullptr</td></tr>
<tr class="memdesc:ad0ae596c1572e8310fff76a4742f9ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the allocated data.  <a href="classdeconvolve_1_1Image.html#ad0ae596c1572e8310fff76a4742f9ff5">More...</a><br /></td></tr>
<tr class="separator:ad0ae596c1572e8310fff76a4742f9ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9348fae5ce1b5a1997717f1c4c7f03a"><td class="memItemLeft" align="right" valign="top">std::array&lt; size_t, <a class="el" href="constants_8hpp.html#aa831695ab6b5b36d12747bb769b9a43e">NDIMS</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#ad9348fae5ce1b5a1997717f1c4c7f03a">m_n</a> {0,0,0}</td></tr>
<tr class="memdesc:ad9348fae5ce1b5a1997717f1c4c7f03a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdeconvolve_1_1Image.html" title="Image class defining memory allocation and all mathematical operations required for deconvolution.">Image</a> dimenstions.  <a href="classdeconvolve_1_1Image.html#ad9348fae5ce1b5a1997717f1c4c7f03a">More...</a><br /></td></tr>
<tr class="separator:ad9348fae5ce1b5a1997717f1c4c7f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae143d90821eb4894fe51ca4656ef2f71"><td class="memItemLeft" align="right" valign="top">std::array&lt; T, <a class="el" href="constants_8hpp.html#aa831695ab6b5b36d12747bb769b9a43e">NDIMS</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#ae143d90821eb4894fe51ca4656ef2f71">m_voxel</a></td></tr>
<tr class="memdesc:ae143d90821eb4894fe51ca4656ef2f71"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdeconvolve_1_1Image.html" title="Image class defining memory allocation and all mathematical operations required for deconvolution.">Image</a> voxel sizes.  <a href="classdeconvolve_1_1Image.html#ae143d90821eb4894fe51ca4656ef2f71">More...</a><br /></td></tr>
<tr class="separator:ae143d90821eb4894fe51ca4656ef2f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6d9c31e1732c6f53b9dae9f9ac9c5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdeconvolve_1_1FFTWPlan.html">FFTWPlan</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a1b6d9c31e1732c6f53b9dae9f9ac9c5a">m_plan_forward</a></td></tr>
<tr class="memdesc:a1b6d9c31e1732c6f53b9dae9f9ac9c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">FFTW forward FFT plan.  <a href="classdeconvolve_1_1Image.html#a1b6d9c31e1732c6f53b9dae9f9ac9c5a">More...</a><br /></td></tr>
<tr class="separator:a1b6d9c31e1732c6f53b9dae9f9ac9c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9661d0021b3ddf82087da732527c09ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdeconvolve_1_1FFTWPlan.html">FFTWPlan</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdeconvolve_1_1Image.html#a9661d0021b3ddf82087da732527c09ed">m_plan_inverse</a></td></tr>
<tr class="memdesc:a9661d0021b3ddf82087da732527c09ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">FFTW inverse FFT plan.  <a href="classdeconvolve_1_1Image.html#a9661d0021b3ddf82087da732527c09ed">More...</a><br /></td></tr>
<tr class="separator:a9661d0021b3ddf82087da732527c09ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class deconvolve::Image&lt; T &gt;</h3>

<p><a class="el" href="classdeconvolve_1_1Image.html" title="Image class defining memory allocation and all mathematical operations required for deconvolution.">Image</a> class defining memory allocation and all mathematical operations required for deconvolution. </p>
<p>This is a core class that defines memory allocation, operations required for deconvolution and interaction with the user-provided <a class="el" href="classdeconvolve_1_1ImageSettings.html" title="Image settings.">ImageSettings</a>. This class is responsible for taking the user data in the form of continuous data arrays, storing it in the format that is suitable for the used internal functions, perform mathematical operations and, on request, return the data to the user as a continuous data array.</p>
<p>The current implementation is based on FFTW library and uses FFTW representation for real and complex data (FFTW is referred to as a backend below). In future, if there will be more approaches to implement deconvolution operations then this class should be separated into an abstract interface, FFTW-based <a class="el" href="classdeconvolve_1_1Image.html" title="Image class defining memory allocation and all mathematical operations required for deconvolution.">Image</a> class and the classes defining other approaches. For example, deconvolution using GPUs is expected to be implemented in such a way. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1aff1ad6a3e670315943f4a8631a7eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aff1ad6a3e670315943f4a8631a7eda">&#9670;&nbsp;</a></span>Image() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Image::Image </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classdeconvolve_1_1ImageSettings.html">ImageSettings</a>&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that copies user-provided data. </p>
<p>Use this constructor to allocate memory in backend-supported format and copy the data from user-provided vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settings</td><td>image settings describing memory storage options and operations </td></tr>
    <tr><td class="paramname">data</td><td>image data vector of size n1*n2*n3 to be copied </td></tr>
    <tr><td class="paramname">n1</td><td>the slowest changing dimension </td></tr>
    <tr><td class="paramname">n2</td><td>the medium changing dimension </td></tr>
    <tr><td class="paramname">n3</td><td>the fastest changing dimension </td></tr>
    <tr><td class="paramname">v1</td><td>voxel size along dimension 1, in meters </td></tr>
    <tr><td class="paramname">v2</td><td>voxel size along dimension 2, in meters </td></tr>
    <tr><td class="paramname">v3</td><td>voxel size along dimension 3, in meters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0f5d42c9e808abdfb2420bc8bb3759b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f5d42c9e808abdfb2420bc8bb3759b">&#9670;&nbsp;</a></span>Image() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Image::Image </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classdeconvolve_1_1ImageSettings.html">ImageSettings</a>&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that only allocates memory. </p>
<p>Use this constructor to allocate memory in backend-supported format. The constructed image data is not initialized and can be used later to store results of mathematical operations on other images.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settings</td><td>image settings describing memory storage options and operations </td></tr>
    <tr><td class="paramname">n1</td><td>the slowest changing dimension </td></tr>
    <tr><td class="paramname">n2</td><td>the medium changing dimension </td></tr>
    <tr><td class="paramname">n3</td><td>the fastest changing dimension </td></tr>
    <tr><td class="paramname">v1</td><td>voxel size along dimension 1, in meters </td></tr>
    <tr><td class="paramname">v2</td><td>voxel size along dimension 2, in meters </td></tr>
    <tr><td class="paramname">v3</td><td>voxel size along dimension 3, in meters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0294f63700543e11c0f0da85601c7ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0294f63700543e11c0f0da85601c7ae5">&#9670;&nbsp;</a></span>~Image()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Image::~Image</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad48349ede7bab0a7f4dc788bea34b2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48349ede7bab0a7f4dc788bea34b2f5">&#9670;&nbsp;</a></span>Image() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeconvolve_1_1Image.html">deconvolve::Image</a>&lt; T &gt;::<a class="el" href="classdeconvolve_1_1Image.html">Image</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af623c8e66010db8e6668d957658a12c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af623c8e66010db8e6668d957658a12c0">&#9670;&nbsp;</a></span>Image() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeconvolve_1_1Image.html">deconvolve::Image</a>&lt; T &gt;::<a class="el" href="classdeconvolve_1_1Image.html">Image</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0d847695e136547b2b0a45db8003277b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d847695e136547b2b0a45db8003277b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeconvolve_1_1Image.html">Image</a>&amp; <a class="el" href="classdeconvolve_1_1Image.html">deconvolve::Image</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae250e2358620e764b32cde5af65c9c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae250e2358620e764b32cde5af65c9c1c">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeconvolve_1_1Image.html">deconvolve::Image</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if image has allocated memory for data. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if memory has been allocated </dd></dl>

</div>
</div>
<a id="a914965c6f3e5da2da2b505fb58e2c9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914965c6f3e5da2da2b505fb58e2c9bd">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Image::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set image data. </p>
<p>Makes a copy of the data in backend-supported internal format</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>image data vector of size n1*n2*n3 to be copied </td></tr>
    <tr><td class="paramname">n1</td><td>the slowest changing dimension </td></tr>
    <tr><td class="paramname">n2</td><td>the medium changing dimension </td></tr>
    <tr><td class="paramname">n3</td><td>the fastest changing dimension </td></tr>
    <tr><td class="paramname">v1</td><td>voxel size along dimension 1, in meters </td></tr>
    <tr><td class="paramname">v2</td><td>voxel size along dimension 2, in meters </td></tr>
    <tr><td class="paramname">v3</td><td>voxel size along dimension 3, in meters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99c6444954e813629c3b6e62caf03603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c6444954e813629c3b6e62caf03603">&#9670;&nbsp;</a></span>copy_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Image::copy_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>im</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from image. </p>
<p>Makes a copy of the data into <code>this</code> from the provided image. Note that the images have to be compatible (same dimensions and voxel sizes).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">im</td><td>image to copy the data from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a490de29909c45c482beb8b0b385004ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490de29909c45c482beb8b0b385004ec">&#9670;&nbsp;</a></span>get_image()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Image::get_image </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get image as a continuous data vector. </p>
<p>Use to get resulting image assuming that stored <code>this-&gt;m_data</code> is real. The given vector is resized to fill the data and then filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>vector to fill the data to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc7fa78613fcc893581b618a3e2db17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7fa78613fcc893581b618a3e2db17b">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Image::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps images between this and provided image. </p>
<p>Swap image data and corresponding structures between this and image given as an argument</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td><a class="el" href="classdeconvolve_1_1Image.html" title="Image class defining memory allocation and all mathematical operations required for deconvolution.">Image</a> to be swapped with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37407e51adfbaedd79672e9874c50ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37407e51adfbaedd79672e9874c50ca0">&#9670;&nbsp;</a></span>same_dims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Image::same_dims </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare given dimensions with the dimensions of <code>this</code> image. </p>
<p>Use to compare <code>this</code> image with the dimensions given as arguments.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the image has the same number of voxels in all dimensions </dd></dl>

</div>
</div>
<a id="a05ced8c24dbb717d7a2d5335e8540e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ced8c24dbb717d7a2d5335e8540e38">&#9670;&nbsp;</a></span>same_dims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Image::same_dims </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare dimensions of the other image with the dimensions of <code>this</code> image. </p>
<p>Overloaded version of <code>same_dims</code>. Use to compare <code>this</code> image with the dimensions of the image given as an argument.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the image has the same number of voxels in all dimensions as the other image </dd></dl>

</div>
</div>
<a id="aad3aaac5f51cf1e0eed7c8fb6e044917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3aaac5f51cf1e0eed7c8fb6e044917">&#9670;&nbsp;</a></span>same_voxel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Image::same_voxel </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare given voxel sizes with the sizes of <code>this</code> image. </p>
<p>Use to compare <code>this</code> image voxel sizes with the sizes given as arguments.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the image has the same voxel sizes in all dimensions </dd></dl>

</div>
</div>
<a id="a19a126b037912f847da38fffefd5206f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a126b037912f847da38fffefd5206f">&#9670;&nbsp;</a></span>same_voxel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Image::same_voxel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare voxel sizes of the other image with the sizes of <code>this</code> image. </p>
<p>Overloaded version of <code>same_voxel</code>. Use to compare <code>this</code> image voxel sizes with the sizes of the image given as an argument.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the image has the same voxel sizes in all dimensions as the other image </dd></dl>

</div>
</div>
<a id="a595c792b085161110efe5170c6a4cbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595c792b085161110efe5170c6a4cbc1">&#9670;&nbsp;</a></span>same_settings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdeconvolve_1_1Image.html">deconvolve::Image</a>&lt; T &gt;::same_settings </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdeconvolve_1_1ImageSettings.html">ImageSettings</a>&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>settings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if the image settings are the same as the settings given by an argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settings</td><td>Settings to be compared to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the settings are identical </dd></dl>

</div>
</div>
<a id="aa7f9edebff0db3e2b02e526b4e9d4700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f9edebff0db3e2b02e526b4e9d4700">&#9670;&nbsp;</a></span>compatible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Image::compatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if other image is compatible to <code>this</code> image. </p>
<p>Checks if <code>this</code> and the other image have the same dimensions, voxels, and have both allocated memory</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the memory was allocated for the both images and voxels and dimensions are the same. </dd></dl>

</div>
</div>
<a id="a4d4cdd5e7aa1d1191faaf1bbf13af025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4cdd5e7aa1d1191faaf1bbf13af025">&#9670;&nbsp;</a></span>fft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Image::fft</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies FFT to this image and keeps it in place. </p>
<p>It it assumed that <code>this</code> holds real data. As a result of this operation, <code>this</code> will be in Fourier space </p>

</div>
</div>
<a id="a29ebe006bdb155c43059abd97b9c0e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ebe006bdb155c43059abd97b9c0e7d">&#9670;&nbsp;</a></span>ifft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Image::ifft</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies IFFT to this image. </p>
<p>It is assumed that <code>this</code> is in Fourier space. After <code>ifft</code>, real data is recovered into <code>this</code>. </p>

</div>
</div>
<a id="aea9f34e977c92dcefe1c7cea729ad834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9f34e977c92dcefe1c7cea729ad834">&#9670;&nbsp;</a></span>convolve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Image::convolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolve this image by the given kernel. </p>
<p>It is assumed that <code>this</code> holds real image and the image given as a kernel is in Fourier space. In addition, the kernel and this image are expected to be <a class="el" href="classdeconvolve_1_1Image.html#aa7f9edebff0db3e2b02e526b4e9d4700">compatible</a>. After operation, <code>this</code> holds the real data corresponding to the convolved image. </p>

</div>
</div>
<a id="a88c1b67b952099a7a1897484bcaaae81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c1b67b952099a7a1897484bcaaae81">&#9670;&nbsp;</a></span>convolve_conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Image::convolve_conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolve this image by conjugate of the given kernel. </p>
<p>It is assumed that <code>this</code> holds real image and the image given as a kernel is in Fourier space. In addition, the kernel and this image are expected to be <a class="el" href="classdeconvolve_1_1Image.html#aa7f9edebff0db3e2b02e526b4e9d4700">compatible</a>. After operation, <code>this</code> holds the real data corresponding to the convolved image. </p>

</div>
</div>
<a id="aab70a4715c14f227f562c6c3f0794e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab70a4715c14f227f562c6c3f0794e4b">&#9670;&nbsp;</a></span>invdivide_image()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Image::invdivide_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation used in deconvolution: this=image/this. </p>
<p>The operation takes value of each voxel in <code>image</code>, divides it by the corresponding voxel value in <code>this</code> and stores the result as a new value for voxel in <code>this</code>. Images (<code>this</code> and <code>image</code>) are expected to be real and <a class="el" href="classdeconvolve_1_1Image.html#aa7f9edebff0db3e2b02e526b4e9d4700">compatible</a>. </p>

</div>
</div>
<a id="ab8609ba2231ee72e3b82ba78fe16f1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8609ba2231ee72e3b82ba78fe16f1d1">&#9670;&nbsp;</a></span>prod_image()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Image::prod_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation used in deconvolution: this=image*this. </p>
<p>The operation takes value of each voxel in <code>image</code>, multiplies it by the corresponding voxel value in <code>this</code> and stores the result as a new value for voxel in <code>this</code>. Images (<code>this</code> and <code>image</code>) are expected to be real and <a class="el" href="classdeconvolve_1_1Image.html#aa7f9edebff0db3e2b02e526b4e9d4700">compatible</a>. </p>

</div>
</div>
<a id="a38a144ccbccc3a55763a39083a940aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a144ccbccc3a55763a39083a940aaa">&#9670;&nbsp;</a></span>div_unit_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Image::div_unit_grad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation used in deconvolution: this=div(grad(image)/mod(grad(image))) </p>
<p>Calculation of divergence of the normalized gradient of the image given as an argument. The result is stored in <code>this</code>. It is expected that <code>image</code> is <a class="el" href="classdeconvolve_1_1Image.html#aa7f9edebff0db3e2b02e526b4e9d4700">compatible</a> with <code>this</code> and <code>image</code> stores real data. </p>

</div>
</div>
<a id="a08575c72311855d9c1e163c60615510c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08575c72311855d9c1e163c60615510c">&#9670;&nbsp;</a></span>prod_regularized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Image::prod_regularized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>div</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation used in deconvolution: this=this*(image/(1-lambda*div)) </p>
<p>Calculation of operation used in regularized deconvolution. Stores result in <code>this</code>. It is expected that <code>image</code> is <a class="el" href="classdeconvolve_1_1Image.html#aa7f9edebff0db3e2b02e526b4e9d4700">compatible</a> with <code>this</code> and <code>image</code> stores real data. </p>

</div>
</div>
<a id="aeb9d5ed38d1af60bfef4938d04958af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9d5ed38d1af60bfef4938d04958af5">&#9670;&nbsp;</a></span>snr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Image::snr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>convolution_kernel_size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peak signal-to-noise of this image. </p>
<p>Find the peak signal-to-noise ratio assuming that the image corresponds to the recordings of Poisson process. This implementation finds the maximal average intensity for <code>this</code> image in a small box with the given kernel size. From the average value, signal-to-noise can be estimated assuming that the recordings are in accordance with the Poisson process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">convolution_kernel_size</td><td>single edge of the box used to find the local average </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>estimated signal-to-noise for <code>this</code> image </dd></dl>

</div>
</div>
<a id="a78a32a20a736cb011bfdd79dac193411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a32a20a736cb011bfdd79dac193411">&#9670;&nbsp;</a></span>get_stats()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Image::get_stats </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>cmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>cmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>csum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classdeconvolve_1_1Image.html" title="Image class defining memory allocation and all mathematical operations required for deconvolution.">Image</a> characteristics in terms of extreme values and sum. </p>
<p>Find minimum, maximum, and the sum of the voxel values in <code>this</code> image</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;tt&gt;cmin&lt;/tt&gt;</td><td>on return, minimum value </td></tr>
    <tr><td class="paramname">&lt;tt&gt;cmax&lt;/tt&gt;</td><td>on return, maximum value </td></tr>
    <tr><td class="paramname">&lt;tt&gt;csum&lt;/tt&gt;</td><td>on return, sum of all voxel values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab74b46e4bbbb05c547d6e7c9dbc74948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74b46e4bbbb05c547d6e7c9dbc74948">&#9670;&nbsp;</a></span>nrm2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Image::nrm2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean norm between <code>this</code> and provided image. </p>
<p>Estimate the difference between <code>this</code> and the image given as an argument using Euclidean norm.</p>
<dl class="section return"><dt>Returns</dt><dd>Euclidean norm between this and provided image </dd></dl>

</div>
</div>
<a id="a1c715981251d16831d293164ed78958d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c715981251d16831d293164ed78958d">&#9670;&nbsp;</a></span>lambda_lsq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Image::lambda_lsq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cconv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>div</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lambda LSQ calculation. </p>
<p>Calculate Lambda LSQ (Equation 5 in <a href="https://doi.org/10.1111/j.1365-2818.2011.03486.x">Laasmaa et al</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cconv</td><td><a class="el" href="classdeconvolve_1_1Image.html" title="Image class defining memory allocation and all mathematical operations required for deconvolution.">Image</a> containing <code>i/(o[s] x h) x conj(h)</code> from the formula </td></tr>
    <tr><td class="paramname">div</td><td><a class="el" href="classdeconvolve_1_1Image.html" title="Image class defining memory allocation and all mathematical operations required for deconvolution.">Image</a> containing divergence of the normalized gradient of <code>o[s]</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lambda LSQ </dd></dl>

</div>
</div>
<a id="aef232b3abecf1483bc541a3bd0175bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef232b3abecf1483bc541a3bd0175bc1">&#9670;&nbsp;</a></span>allocate_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Image::allocate_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate data in the format suitable for the backend. </p>

</div>
</div>
<a id="a9fa0200796f28aab5dfe43d9a539b0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa0200796f28aab5dfe43d9a539b0df">&#9670;&nbsp;</a></span>release_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Image::release_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the allocated data. </p>

</div>
</div>
<a id="ac4aa2cc5173baa94983bd9f4dd65e9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4aa2cc5173baa94983bd9f4dd65e9ae">&#9670;&nbsp;</a></span>convolve_implementation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Image::convolve_implementation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdeconvolve_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(std::complex&lt; T &gt; *im, std::complex&lt; T &gt; *ker, T scale, size_t sz)&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of convolution. </p>
<p>Implementation of generalized convolution allowing to convolve <code>this</code> with the kernel or its conjugated form. </p>

</div>
</div>
<a id="a1723bfcefda9544ffc27bad9b408dab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1723bfcefda9544ffc27bad9b408dab2">&#9670;&nbsp;</a></span>last_dim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Image::last_dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the last dimension in the format used by FFTW. </p>

</div>
</div>
<a id="a16382f0ec9774c0ce34b2a19e6bf0d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16382f0ec9774c0ce34b2a19e6bf0d01">&#9670;&nbsp;</a></span>data_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Image::data_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns data size assuming that its all stored as real numbers. </p>

</div>
</div>
<a id="af1afd770e6fea1bbb41b5df86119512f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1afd770e6fea1bbb41b5df86119512f">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; Image::operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the voxel value assuming that <code>this</code> holds real data. </p>

</div>
</div>
<a id="a2f89e72ed76a5a052ee6bb82b03a6ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f89e72ed76a5a052ee6bb82b03a6ebb">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Image::operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the voxel value assuming that <code>this</code> holds real data. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3281fa4ff2a8875e7828f3d0ed9223a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3281fa4ff2a8875e7828f3d0ed9223a9">&#9670;&nbsp;</a></span>m_settings</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classdeconvolve_1_1ImageSettings.html">ImageSettings</a>&lt;T&gt; &gt; <a class="el" href="classdeconvolve_1_1Image.html">deconvolve::Image</a>&lt; T &gt;::m_settings</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Settings used to allocate memory and keeping configuration of relevant parameters. </p>

</div>
</div>
<a id="ad0ae596c1572e8310fff76a4742f9ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ae596c1572e8310fff76a4742f9ff5">&#9670;&nbsp;</a></span>m_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classdeconvolve_1_1Image.html">deconvolve::Image</a>&lt; T &gt;::m_data = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the allocated data. </p>

</div>
</div>
<a id="ad9348fae5ce1b5a1997717f1c4c7f03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9348fae5ce1b5a1997717f1c4c7f03a">&#9670;&nbsp;</a></span>m_n</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;size_t, <a class="el" href="constants_8hpp.html#aa831695ab6b5b36d12747bb769b9a43e">NDIMS</a>&gt; <a class="el" href="classdeconvolve_1_1Image.html">deconvolve::Image</a>&lt; T &gt;::m_n {0,0,0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classdeconvolve_1_1Image.html" title="Image class defining memory allocation and all mathematical operations required for deconvolution.">Image</a> dimenstions. </p>

</div>
</div>
<a id="ae143d90821eb4894fe51ca4656ef2f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae143d90821eb4894fe51ca4656ef2f71">&#9670;&nbsp;</a></span>m_voxel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, <a class="el" href="constants_8hpp.html#aa831695ab6b5b36d12747bb769b9a43e">NDIMS</a>&gt; <a class="el" href="classdeconvolve_1_1Image.html">deconvolve::Image</a>&lt; T &gt;::m_voxel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classdeconvolve_1_1Image.html" title="Image class defining memory allocation and all mathematical operations required for deconvolution.">Image</a> voxel sizes. </p>

</div>
</div>
<a id="a1b6d9c31e1732c6f53b9dae9f9ac9c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6d9c31e1732c6f53b9dae9f9ac9c5a">&#9670;&nbsp;</a></span>m_plan_forward</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeconvolve_1_1FFTWPlan.html">FFTWPlan</a>&lt;T&gt; <a class="el" href="classdeconvolve_1_1Image.html">deconvolve::Image</a>&lt; T &gt;::m_plan_forward</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FFTW forward FFT plan. </p>

</div>
</div>
<a id="a9661d0021b3ddf82087da732527c09ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9661d0021b3ddf82087da732527c09ed">&#9670;&nbsp;</a></span>m_plan_inverse</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdeconvolve_1_1FFTWPlan.html">FFTWPlan</a>&lt;T&gt; <a class="el" href="classdeconvolve_1_1Image.html">deconvolve::Image</a>&lt; T &gt;::m_plan_inverse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FFTW inverse FFT plan. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cpp/src/<a class="el" href="image_8hpp_source.html">image.hpp</a></li>
<li>cpp/src/<a class="el" href="image_8cpp.html">image.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
