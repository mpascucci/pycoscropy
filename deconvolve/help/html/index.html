<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IOCBIO Deconvolve: IOCBIO Deconvolution</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IOCBIO Deconvolve
   </div>
   <div id="projectbrief">Library for deconvolving 3D images</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">IOCBIO Deconvolution </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> This is a C++ library for performing deconvolution on 3D images. In particular, we are targeting the images acquired by microscopes, such as confocal microscopes. The library provides C++ and Python API with the view of simple integration into the other software. At present, deconvolution algorithm as in <a href="https://doi.org/10.1111/j.1365-2818.2011.03486.x">Laasmaa et al</a> is implemented. This is the second implementation of this algorithm using cleaner API and is recommended to be used instead of the first one.</p>
<p>The library provides non-regularized and regularized Richardsonâ€“Lucy algorithms. In practice, it is recommended to use regularized deconvolution. The implemented algorithms assume that the image is recorded with Poisson noise. This should be applicable to the images acquired on common microscopes but may require some preprocessing on user's side. See below for specific image requirements for achieving the best results.</p>
<p>Internally, the library uses <a href="http://www.fftw.org">FFTW</a> to accelerate convolution operations required during the iteration process. The library is written in a way that should allow replacing FFTW and other image manipulation operations by some other approaches that could improve the performance further.</p>
<p>The library is thread safe as long as care is taken to perform FFTW plan operations in thread safe manner. The default implementation of FFTW plan handling is done in thread safe manner and the means for user-defined FFTW plan handling are provided as well.</p>
<p>If using the library for research, please refer to Laasmaa, M., Vendelin, M., &amp; Peterson, P. (2011). Application of regularized Richardson-Lucy algorithm for deconvolution of confocal microscopy images. Journal of Microscopy, 243(2), 124-140. <a href="https://doi.org/10.1111/j.1365-2818.2011.03486.x">https://doi.org/10.1111/j.1365-2818.2011.03486.x</a> . This is not required to use the library, but very much appreciated.</p>
<h1>Deconvolution process</h1>
<p>Deconvolution is rather simple as soon as you have the image, PSF of the microscope and know the detection properties of your microscope. In particular, through provided API, you specify PSF, and then the image to deconvolve. The tricky part is to figure out when to stop deconvolution and, if using the regularized algorithm, what is the first regularization factor value.</p>
<p>The library provides same defaults and the means to control stopping criterion as well as regularization factor by the provided callback. Users are encouraged to implement callback when integrating the library into their larger applications to provide GUI feedback of deconvolution process to the end user.</p>
<p>The default stopping criterion for regularized deconvolution is based on following regularization factor evolution during iterations, as in <a href="https://doi.org/10.1111/j.1365-2818.2011.03486.x">Laasmaa et al</a>. For non-regularized deconvolution, the iterations are stopped after a predefined number of iterations. For non-regularized deconvolution, please provide the callback to stop iterations as feasible.</p>
<h1>Image requirements</h1>
<p>When acquiring images on the microscope, the photon counts are frequently linearly transformed into data counts (DN) stored as a voxel value in the image. For this linear transformation, offset and gain are commonly used and are addressed below. To comply with the Poisson noise requirement of the implemented algorithms, some pre-processing has to be performed before deconvolving images.</p>
<h2>General image requirements</h2>
<p>It is expected that the recorded image noise is not dominated by the readout noise of the detector. In practice, it means that the integration time has to be sufficiently long. In addition, all spatial requirements for the deconvolution have to be met. It is recommended to oversample the data to obtain better statistics, if allowed by hardware and the imaged sample.</p>
<p>When recording data for deconvolution, it is essential to preserve full data range in the recordings. Namely, minimal and maximal DNs of the image should be larger than zero and smaller than maximal possible value, respectively.</p>
<p>We have seen several students and researchers who like to set offset so low that the minimal DN is zero effectively artificially reducing the background of the images. Please note that such images, while possibly nice to look at, are useless for any quantitative processing like deconvolution.</p>
<p>Since you may have to determine offset experimentally (see below), you have to use such settings that DNs are above zero in the absence of any light as well. Hence, when adjusting the settings in the microscope, make sure that dark image offset is also above zero.</p>
<p>While not as popular as the artificial reduction of noise by offset, adjustments of the gain should be taken with care as well. The maximal DN of the image should not be reaching the maximal values of the data range of the detector and data representation (whatever comes first). To check it, a user can calculate the histogram of the image and observe whether the maximal DNs are just in few pixels or form a significant population. When forming significant population, its most probably due to reaching some of the limits and the gain has to be reduced.</p>
<h2>Offset</h2>
<p>Regardless of whether regularized or non-regularized deconvolution is used, it is important to subtract offset between DN and number of photon-generated electrons. Thus, you have to subtract DN corresponding to the case when there is no light falling on the detector. Note that this is different from the image background level which may contain some light bleed-through.</p>
<p>To determine the offset, record with the same imaging settings, as you do for your data images, some series without any light. For confocal microscopes, we would recommend to switch off the lasers (through AOTF, for example) and record in the dark room.</p>
<p>Unfortunately, the offset can depend on microscope settings and has to be determined when detector settings are changed. This is in particular of importance for the users of confocal microscopes equipped with PMTs. Thus, in practice, users of such microscopes should know the offset for the specific used settings.</p>
<p>If you record the data through cameras, camera manufacturers sometimes specify the offset in the data sheets or programming API description. For the cameras we have had access to (some Andor and Hamamatsu), the offset is close to 100 DN.</p>
<p>So, when submitting the image for deconvolution, subtract the offset from the recorded data. In practice, due to the noise, there will be some negative values after such subtraction. For these locations, we recommend setting the values to zero.</p>
<h2>Gain</h2>
<p>Knowledge of gain is required when using regularized deconvolution algorithm, as recommended and set by default in this library. While sometimes non-trivial, determination of gain is possible by the end users.</p>
<p>In general, deconvolution process does not require gain. Indeed, as it is clear from the used formulas, scaling of the data image would result in the same scaling of the deconvolved one (<a href="https://doi.org/10.1111/j.1365-2818.2011.03486.x">Laasmaa et al</a>). However, we need the gain to determine signal-to-noise (SNR) of the image to calculate the first estimate of the regularization factor. As shown in <a href="https://doi.org/10.1111/j.1365-2818.2011.03486.x">Laasmaa et al</a>, the optimal results of deconvolution can be obtained if the regularization factor is <code>50/SNR</code> where SNR denotes peak signal-to-noise ratio. To determine peak SNR, we need to transform the image into the units that would make it comply with Poisson noise and, after the transformation, calculate SNR from the intensity values using the property of Poisson process that relates its variance to the mean value.</p>
<p>In this library, user has a choice of either provide Poisson noise fully compliant image by removing offset from DNs (covered above) and dividing them with the gain before providing data to the library:</p>
<div class="fragment"><div class="line">data_for_deconvolving = (DN-offset) * gain</div>
</div><!-- fragment --><p>where <em>gain</em> is in <em>electrons/DN</em>.</p>
<p>Alternatively, a user can determine SNR of the data image. We suggest to use the first approach, determine gain, transfer the DNs to photons and use this data for deconvolution.</p>
<h3>Determination of gain</h3>
<p>For the purpose of SNR estimation, as in this library, the gain does not have to be determined precisely. Namely, you would need to know the ballpark of the gain. We would expect that 10-25% difference from estimated to true gain would be important. However, setting it off by several times would probably lead to the wrong estimation of the first regularization parameter and may result in the failed deconvolution.</p>
<p>To determine the gain, you would have to measure photon transfer curve for your microscope at the used settings. For users recording the data using sCMOS cameras, it will be probably sufficient to determine the gain for a single set of parameters (acquisition time) and use it in an adjustment of the image. When determined on the cameras available to us, the gain was dependent on integration time, but for the purpose of this application, it could probably be considered the same. Note that for sCMOS cameras, the gain could be specified by the manufacturer.</p>
<p>For other microscope detectors (PMT, EMCCD), you would probably have to determine the gain in your particular settings. The specific procedure is out of the scope of this README, and you are welcome to consult the literature, for example <a href="http://harvestimaging.com/blog/?p=1034">2</a>. In short, it will require measurement of time series at different illumination levels, determination of variability at each pixel, and linear fitting of the relationship between variance and mean value of the intensity. However, please see dedicated description for details.</p>
<h2>Compensation for averaging</h2>
<p>Another aspect in common imaging that would influence noise distribution is averaging of the images. By averaging, you take the photon counts, sum them up and divide by the number of times you performed the images. This operation is improving SNR of the image, but it will be invisible to the SNR estimator of this library. To account for better SNR of the averaged image, please multiply the image data values by the number of times you averaged the data. This will transform the image into the correct number of photons before deconvolution allowing the routines to correctly estimate the regularization parameter.</p>
<h2>Users with photon counters</h2>
<p>Users of microscopes equipped with the photon counters that record data in photon counts, such adjustment of offset and gain is not needed, as long as no averaging is performed. Namely, in this case, the offset is zero, the gain is one, and recorded data complies with the Poisson noise requirements. However, such microscopes are rare and usually custom built on site.</p>
<h2>Formula for image data</h2>
<p>To summarize, the image expected by the deconvolution routine is</p>
<div class="fragment"><div class="line">to_deconvolve = Naveraging * (image-offset) * gain</div>
</div><!-- fragment --><p>where</p>
<ul>
<li><em>Naveraging</em> number of images used for averaging</li>
<li><em>image</em> original data</li>
<li><em>offset</em> detector data offset in the dark, in DN</li>
<li><em>gain</em> detector gain, in electron/DN</li>
</ul>
<h1>PSF requirements</h1>
<p>The library requires point spread function (PSF) as one of the inputs. PSF describes optical properties of a microscope used for imaging and, therefore, it is essential to have it as good as possible to obtain the best deconvolution result. There are two possibilities for determination of PSF of the optical system:</p>
<ol type="1">
<li>theoretically calculated;</li>
<li>experimentally measured.</li>
</ol>
<p>PSF depends on various parameters of an optical system. For example, emission and excitation wavelength, the refractive index of sample medium, objective numerical aperture (NA), pinhole size in front of the detector, and alignment of optical elements in the light path. Thus, it is important to use the PSF that is measured or calculated for the imaging settings that correspond to the deconvolved images.</p>
<h2>Measuring PSF</h2>
<p>PSF should be measured from fluorescent beads that are smaller than optical resolution at given excitation wavelength. For visible light, bead diameter should be ~100 nm or smaller. When imaging fluorescent beads it is essential to oversample. For the range of visible light pixel sizes in XY-plane should be ~50 nm and Z direction ~100 nm. Also, the quality of PSF benefits from the large number of beads captured and high SNR, i.e. longer exposure times and taking advantage of full detector dynamic range (up to 90%). Thus, ideally, PSF should be estimated from the slides that have only small beads to be able to use the dynamic range as much as possible.</p>
<h1>API description</h1>
<p>In C++, the library is contained in <code>deconvolve</code> namespace. The API is exposed through <a class="el" href="classdeconvolve_1_1Deconvolve.html" title="Deconvolution and convolution of 3D images.">deconvolve::Deconvolve</a> class. This class and the callback function <a class="el" href="namespacedeconvolve.html#ac2deaea008754b189d8406f63394bce9" title="Callback function type used to communicate during deconvolution. For use from C.">deconvolve::callback_type</a> (or its variants <a class="el" href="namespacedeconvolve.html#aa9ff52654810ed9c2b4195bc63351d05" title="Extended callback function type used to communicate during deconvolution.">deconvolve::callback_extended_type</a> and <a class="el" href="namespacedeconvolve.html#a651bedf17c041d67a0125de6275bc5c1" title="Callback function type used to communicate during deconvolution. For use from C++.">deconvolve::callback_cpp_type</a>) are the types of interest to the end user. In addition, it is possible to use user-provided FFTW plan handling routines. This allows the user to configure FFTW plan storage and loading outside of the library. See <a class="el" href="classdeconvolve_1_1Deconvolve.html#a373fcd925ac94d344c75be98bb4e1084" title="Set FFTW plan handling functions.">deconvolve::Deconvolve::set_fftw_handlers</a> for the description of the interface. All other classes are implementation details that should be of interest only to the library developer.</p>
<p>Python API mirrors the API provided by C++ through PyDeconvolve in <code>python/calc/cpp_calc.pyx</code> Cython implementation.</p>
<p>Within this library, all voxel dimensions are expected in meters. Images and PSF are expected as floating type (double or float) vectors.</p>
<h2>Usage</h2>
<p>In typical case, user is expected to construct an object of <a class="el" href="classdeconvolve_1_1Deconvolve.html" title="Deconvolution and convolution of 3D images.">deconvolve::Deconvolve</a> class, provide it a PSF through its set_psf method, specify callback function or a maximal number of iterations, and perform the deconvolution:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line"> </div>
<div class="line">deconvolve::Deconvolve dec;</div>
<div class="line">dec.set_psf(psf_vector, n1, n2, n3, v1, v2, v3);</div>
<div class="line">std::vector&lt;double&gt; deconvolved = dec.deconvolve(data_vector, dn1, dn2, dn3, dv1, dv2, dv3);</div>
</div><!-- fragment --><p>See API documentation for <a class="el" href="classdeconvolve_1_1Deconvolve.html" title="Deconvolution and convolution of 3D images.">deconvolve::Deconvolve</a> and callback function type description for details.</p>
<h1>Compilation of modules</h1>
<p>The library supports use of OpenMP for multi-threaded deconvolution. To enable OpenMP extensions, you would have to compile the library with the corresponding switches. In addition, C++ API allows specifying external FFTW handling routines allowing users to implement FFTW plan handling and multi-threading.</p>
<h2>Requirements</h2>
<p>The library requires:</p>
<ul>
<li>C++11 compilator, tested on gcc 6.4.0</li>
<li><a href="http://www.fftw.org/">FFTW</a></li>
<li>For Python: python3, cython, numpy</li>
</ul>
<h2>C++</h2>
<p>C++ API can be compiled using</p>
<div class="fragment"><div class="line">make openmp=1 fftw_threads=1</div>
</div><!-- fragment --><p>in the root directory of the project. Switches <code>openmp=1</code> and <code>fftw_threads=1</code> allow to enable OpenMP support for data operations (<code>openmp=1</code>) and handling of FFTW multi-threaded support through OpenMP (<code>fftw_threads=1</code>).</p>
<p>C++ compiler, its options and used libraries can be configured at the top of <code>cpp/Makefile</code>.</p>
<p>Management of FFTW plans can be handled through external routines. This allows users to integrate the library into multithreaded programs and ensure that FFTW plans are handled only by one thread at a time as well as manage storage and loading of FFTW plans.</p>
<h2>Python</h2>
<p>Python interface can be compiled by</p>
<div class="fragment"><div class="line">(cd python/calc &amp;&amp; python3 setup.py build_ext --inplace)</div>
</div><!-- fragment --><p>See <code>python/tests/test_deconvolve.py</code> for usage example.</p>
<h1>Generation of API documentation</h1>
<p>Doxygen API description can be generated by running <code>make help</code> in the root directory of the library.</p>
<h1>License</h1>
<p>Code is distributed under GPLv3 as described in [COPYING](COPYING). Authors are listed in AUTHORS. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
